{
  "posts": [
    {
      "category": "paper",
      "_id": "5e8f5fafa449db00108cb2cb",
      "title": "Banking via Handy - Akzeptanz altersgruppenspezifisch?",
      "html": "Die digitalisierende Bankbranche sehnt ihn förmlich herbei: Den Durchbruch des Mobile Banking auch in Deutschland. Mobile Banking als zusätzlicher Distributionskanal wird für traditionelle Geldinstitute überlebenswichtig, um neue Kunden zu gewinnen und bestehende Kundenbeziehungen zu erhalten. Doch die Realität scheint momentan noch eine andere: Im internationalen Vergleich vertrauen nur wenige Deutsche ihre Bankgeschäfte ihrem Handy an. Unter den älteren Bevölkerungsgruppen zeigt sich eine besonders hohe Skepsis dieser Technologie gegenüber. Um dem Phänomen des Mobile Bankings auf die Spur zu kommen, beginnt das Paper mit einer kurzen Einführung in Begrifflichkeiten zum Thema und die Einbeziehung medienpsychologischer Aspekte zur Akzeptanz innovativer Technologien. Schließlich werden einige internationale Studienergebnisse zusammengefasst, die sich mit dem Einflussfaktor Alter als Einflussfaktor auf die Akzeptanz von Mobile Banking befasst haben.\n\n*Exner, Ulrike: Banking via Handy - Akzeptanz altersgruppenspezifisch?, 2015. [Download](../../../img/uploads/06ca9125e5754d08a272cd91350ec8f7.pdf)*\n",
      "slug": "mobile-banking-altersgruppenspezifisch",
      "date": "2015-12-02",
      "createdAt": "2020-04-09T17:47:27.676Z",
      "updatedAt": "2020-04-18T18:08:04.531Z",
      "__v": 0,
      "id": "5e8f5fafa449db00108cb2cb"
    },
    {
      "category": "paper",
      "_id": "5e8f64efa449db00108cb2ce",
      "html": "Die Sehnsucht nach verlässlichen intelligenten Agenten mit scheinbar eigener Persönlichkeit scheint groß zu sein. Wir lassen uns heute durch Apples \"Siri\" oder Microsofts \"Cortana\" den Weg zeigen oder einen Restauranttisch buchen. Doch die Evolution von intelligenten Agenten ist eine Geschichte mit Höhen und Tiefen. Ein berühmter Vertreter einer einfachen Form von interface agents ist Microsofts \"Clippy the Paperclip\" - eine tragische Figur auf dem Experimentierfeld der Künstlichen Intelligenz, der schon vor Beginn ihres Untergangs mit Häme und Spott begegnet wurde. Neue Entwicklungen versprechen innnovative agents, die sich das Internet zu Nutze machen. Das Paper beinhaltet die jeweiligen Entwicklungslinien.\n\n*Exner, Ulrike: \"Die, Clippy, die!!\" Zur Evolution von User Interface Agents und aktuelle Entwicklungen bei Intelligent Personal Assistants, 2016. [Download](../../../img/uploads/2cfde365744a43028b90b8621fca16cd.pdf)*",
      "title": "\"Die, Clippy, die!!\". Die Evolution von User Interface Agents und aktuelle Entwicklungen bei Intelligent Personal Assistants",
      "slug": "die-clippy-die-intelligent-personal-assistants",
      "date": "2016-06-13",
      "createdAt": "2020-04-09T18:09:51.522Z",
      "updatedAt": "2020-04-18T18:07:58.333Z",
      "__v": 0,
      "id": "5e8f64efa449db00108cb2ce"
    },
    {
      "category": "paper",
      "_id": "5e917eebde6c310010be67be",
      "html": "<!-- wp:paragraph -->\n\nDas World Wide Web stellt über unterschiedlichste Kanäle eine Vielzahl von potentiell relevanter Information zu diversen Fragestellungen bereit. Insbesondere Unternehmen sind jedoch darauf angewiesen, stets den Überblick über technologische Neuerungen, Marktdaten und sonstige Trends zu behalten. Neben der Erhebung kann auch die Verarbeitung, Analyse und Präsentation von relevanten Daten aus dem Web heute mit Web-Monitoring- Tools unterstützt werden. Die vorliegende Masterarbeit dokumentiert die Entwicklung eines Web-Monitoring-Tools zur Anwendung und Implemen- tierung für einen Engineering-Dienstleister im Automobilbereich. Zur Voranalyse werden einerseits der aktuelle Forschungsstand sowie wichtige Konzepte im Umfeld von Web-Monitoring-Technologien dargelegt. Andererseits werden als eigene empirische Forschung potentielle Nutzer über ihre Anforderungen und Erwartungen an das System in qualitativen Interviews befragt. Die daraus gewonnenen Erkenntnisse gehen im Sinne des Human-Centered-Design direkt in die Konzeption ein. In einem schlanken Feature-Driven-Development-Prozess wird ein Web-Monitoring-Tool mit Hilfe von modernen Webentwicklungstechnologien wie AngularJS, Flask und MongoDB umgesetzt. Der Prototyp wird abschließend unter Anwendung eines Nutzertests und eines Fragebogens einer summativen Evaluation unterzogen.\n\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\nExner, Ulrike: Nutzerzentrierte Entwicklung eines prototypischen Web-Monitoring-Tools, 2017. [https://opus4.kobv.de/opus4-fhbrb/frontdoor/index/index/docId/2192](https://opus4.kobv.de/opus4-fhbrb/frontdoor/index/index/docId/2192).\n\n<!-- /wp:paragraph -->",
      "title": "Nutzerzentrierte Entwicklung eines prototypischen Web-Monitoring-Tools",
      "slug": "nutzerzentrierte-entwicklung-eines-prototypischen-web-monitoring-tools",
      "date": "2017-06-01",
      "createdAt": "2020-04-11T08:25:15.736Z",
      "updatedAt": "2020-04-11T08:25:15.736Z",
      "__v": 0,
      "id": "5e917eebde6c310010be67be"
    },
    {
      "category": "tutorial",
      "_id": "5e917f8dde6c310010be67bf",
      "html": "<!-- wp:paragraph -->\n\nIn diesem Tutorial geht es darum, den auf Python basierenden SimpleHTTP-Server zu installieren und zu testen. Dieses Tutorial ist im Rahmen der Bremer [SummerSchool \"Informatica Feminale\"](https://www.informatica-feminale.de/) für den Kurs \"Einführung in die modere Webentwicklung\" entstanden.\n\n<!-- /wp:paragraph -->\n\n<!-- wp:more -->\n\n<!--more-->\n\n<!-- /wp:more -->\n\n<!-- wp:paragraph -->\n\nJe nachdem, welche Python-Version auf deinem Betriebssystem installiert ist, befolge die weiteren Schritte zur Installation eines kleinen Webservers auf deinem Computer. Wie du die Python-Version identifizierst, lernst du [in diesem Tutorial](http://rike.dev/2017/07/28/der-terminal-und-python-installieren/).\n\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n\n*   Lege auf deinem Computer einen Ordner an, in dem du während des Kurses arbeiten möchtest. Den Ort kannst du beliebig festlegen.\n*   Innerhalb dieses Ordners lege eine neue Datei an (in Windows z. B. per Rechtsklick: \"Neues Textdokument\")!\n*   Benenne die Datei um in \"index.html\"!\n*   Öffne die Datei in einem Texteditor (z. B. \"Sublime\") und füge einen beliebigen Text ein, z. B. \"Hello World!\"\n*   Öffne ein neues Terminal-Fenster (es ist kein Problem, mehrere Terminal-Fenster parallel laufen zu lassen) und navigiere zum neu angelegten Ordner. Der Befehl dazu lautet \"cd\" gefolgt vom entsprechenden Pfad.\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n\nFür ein Windows-System könnte der Befehl so lauten:\n\n<!-- /wp:paragraph -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\">cd C:\\Users\\Ulrike\\Projekte\\Webentwicklung</pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:paragraph -->\n\nFür ein macOS-System wäre dies ein Beispiel-Befehl:\n\n<!-- /wp:paragraph -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\">cd /Volumes/PROJECTS/Webentwicklung</pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:paragraph -->\n\nWenn du erfolgreich warst, wird der Pfad, in dem du dich nun befindest, der neuen Kommandozeile voran gestellt.\n\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\nDa wir Python installiert haben, und Python in der Standardausführung bereits ein kleines \"Werkzeug\" für einen einfach Webserver mitbringt, müssen wir diesen Webserver jetzt nur noch starten.\n\n<!-- /wp:paragraph -->\n\n<!-- wp:heading -->\n\n### Anleitung für Python 2.x.x\n\n<!-- /wp:heading -->\n\n<!-- wp:list -->\n\n*   Prüfe noch einmal, ob du dich in deinem Terminal im richtigen Dateipfad befindest. Wenn ja, gib ins Terminal den folgenden Befehl ein:\n<!-- /wp:list -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\">python -m SimpleHTTPServer</pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:list -->\n\n*   Solltest du eine Warnmeldung von deiner Firewall erhalten, klicke auf \"Ok\" bzw. \"Zulassen\".\n*   Navigiere in deinem Browser zur URL [http://127.0.0.1:8000/](http://127.0.0.1:8000/).  Wenn alles geklappt hat, wird dort nun der Inhalt des von dir angelegten HTML-Dokuments angezeigt, also z. B. \"Hello World\".\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n\nGlückwunsch! Du hast deinen ersten lokalen Webserver eingerichtet!\n\n<!-- /wp:paragraph -->\n\n<!-- wp:heading -->\n\n### Anleitung für Python 3.x.x\n\n<!-- /wp:heading -->\n\n<!-- wp:list -->\n\n*   Prüfe noch einmal, ob du dich in deinem Terminal im richtigen Dateipfad befindest. Wenn ja, gib ins Terminal den folgenden Befehl ein:\n<!-- /wp:list -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\">python -m http.server</pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:list -->\n\n*   Solltest du eine Warnmeldung von deiner Firewall erhalten, klicke auf \"Ok\" bzw. \"Zulassen\".\n*   Navigiere in deinem Browser zur URL http://127.0.0.1:8000/. Wenn alles geklappt hat, wird dort nun der Inhalt des von dir angelegten HTML-Dokuments angezeigt, also z. B. \"Hello World\".\n<!-- /wp:list -->\n\n<!-- wp:image {\"id\":21,\"align\":\"center\",\"linkDestination\":\"media\",\"className\":\"wp-image-291 size-full imagedropshadow\"} -->\n<div class=\"wp-block-image wp-image-291 size-full imagedropshadow\">\n<figure class=\"aligncenter\">![\"Hello World\" im Browser unter der lokalen URL http://127.0.0.1:8000/](../../../img/uploads/02abc1f273e14f57a8d4ba6efb8d4b4b.png)\n<figcaption>\"Hello World\" im Browser unter der lokalen URL http://127.0.0.1:8000/</figcaption>\n</figure>\n</div>\n<!-- /wp:image -->\n\n<!-- wp:heading -->\n\n### Den Webserver stoppen\n\n<!-- /wp:heading -->\n\n<!-- wp:list -->\n\n*   Den gestarteten Webserver kannst du jederzeit wieder stoppen. Dann ist er nicht mehr unter der URL http://127.0.0.1:8000/ erreichbar. Im Terminal musst du dazu lediglich [Strg] + [C] bzw. [Ctrl] + [C] drücken.\n<!-- /wp:list -->",
      "title": "Einen einfachen Webserver mit Python 2.x.x oder 3.x.x installieren",
      "date": "2017-08-29",
      "slug": "mit-dem-terminal-arbeiten-und-python-installieren",
      "createdAt": "2020-04-11T08:27:57.792Z",
      "updatedAt": "2020-04-11T08:37:05.385Z",
      "__v": 0,
      "id": "5e917f8dde6c310010be67bf"
    },
    {
      "category": "tutorial",
      "_id": "5e918281de6c310010be67c2",
      "html": "<!-- wp:paragraph -->\n\nIn diesem Tutorial lernst du, wie du mit dem Terminal deines Betriebssystems arbeitest, die Programmiersprache installierst und testest. Dieses Tutorial ist im Rahmen der Bremer [SummerSchool \"Informatica Feminale\"](https://www.informatica-feminale.de/) für den Kurs \"Einführung in die modere Webentwicklung\" entstanden.\n\n<!-- /wp:paragraph -->\n\n<!-- wp:more -->\n\n<!--more-->\n\n<!-- /wp:more -->\n\n<!-- wp:heading {\"level\":3} -->\n\n### Mit dem Terminal arbeiten / Python-Installation prüfen\n\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n\nMit dem Terminal können wir unser Betriebssystem _textbasiert_ steuern. Häufigster Vorbehalt gegen das Terminal ist, dass es komplex und damit schwierig zu erlernen sei. Für einige Aufgaben ist er jedoch sehr gut geeignet, weswegen wir für dieses Tutorial / den Kurs ein wenig damit arbeiten werden.\n\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n\n*   Öffne das Terminal (= Kommandozeile oder CLI oder Konsole) deines Betriebssystems:\n\n    *   In **Windows 8 und 10** geht das mit einem Klick mit der rechten Maustaste unten links im Bildschirm auf das Windows-Symbol oder mit der Tastenkombination [Windows] und [X]. Danach muss die \"Eingabeaufforderung\" oder die \"Eingabeaufforderung (Administrator)\" aus der Liste ausgewählt werden.\n    *   In **Windows 7** klickst du auf das Windows-Symbol links unten und suchst unter \"Dateien/Programme durchsuchen\" nach \"Eingabeaufforderung\".\n    *   In vielen **Linux**-Distributionen öffnet sich das Terminal durch die Tastenkombination [Strg] + [Alt] + [T].\n    *   Auf **MacOS** führt die Tastenkombination [cmd] + [Leertaste] zur Spotlight-Suche. Dort kann nach \"Terminal\" gesucht und dieser ausgeführt werden.\n\n*   Nun prüfen wir, ob auf unserem Betriebssystem bereits die Programmiersprache _Python _installiert ist. Die Chancen stehen gut, denn MacOS und viele Linux-Distributionen bringen_ Python_ bereits mit. Gib im Terminal ein. Im besten Fall informiert dich dein Betriebssystem nun darüber, ob und in welcher Version _Python_ installiert ist. Wenn das der Fall ist, musst du an dieser Stelle nichts weiter tun (es ist egal, welche Python-Version du nutzt)!\nSolltest du eine Fehlermeldung erhalten, musst du die Installation von Python für dein Betriebssystem nachholen (nächster Schritt).\n<!-- /wp:list -->\n\n<!-- wp:image {\"id\":14,\"align\":\"center\",\"linkDestination\":\"media\",\"className\":\"wp-image-286 size-full imagedropshadow\"} -->\n<div class=\"wp-block-image wp-image-286 size-full imagedropshadow\">\n<figure class=\"aligncenter\">![Dieses macOS-System informiert darüber, dass Python in der Version 2.7.10 installiert ist und zur Nutzung bereit steht.](../../../img/uploads/7701c4839b8e4e61bc1170653dccb21c.png)\n<figcaption>Dieses macOS-System informiert darüber, dass Python in der Version 2.7.10 installiert ist und zur Nutzung bereit steht.</figcaption>\n</figure>\n</div>\n<!-- /wp:image -->\n<!-- wp:image {\"id\":15,\"align\":\"center\",\"linkDestination\":\"media\",\"className\":\"wp-image-282 size-full imagedropshadow\"} -->\n<div class=\"wp-block-image wp-image-282 size-full imagedropshadow\">\n<figure class=\"aligncenter\">![Dieses Windows-System hat leider noch keine Python-Installation vorliegen.](../../../img/uploads/a569afa6efc54a6b8946f70bfc38a2cd.png)<figcaption>Dieses Windows-System hat leider noch keine Python-Installation vorliegen.</figcaption>\n</figure>\n</div>\n<!-- /wp:image -->\n\n<!-- wp:heading {\"level\":3} -->\n\n### Python installieren (empfohlen: Version 3.x.x)\n\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n\nPython können wir wie ein normales Softwarepaket herunterladen und für unser Betriebssystem installieren. Die Programmiersprache ist Open-Source, das heißt kostenlos erhältlich.\n\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n\n*   Surfe zu https://www.python.org/downloads/ und lade den jüngsten Release von _Python 3_.xx herunter, momentan ist das _Python 3.6.2_. Achte darauf, dass du das Paket für dein Betriebssystem herunterlädst, normalerweise erkennt die Website dein Betriebssystem automatisch und schlägt dir die richtige Datei vor.\n<!-- /wp:list -->\n\n<!-- wp:image {\"id\":16,\"linkDestination\":\"media\",\"className\":\"imagedropshadow\"} -->\n<figure class=\"wp-block-image imagedropshadow\">[![Python Download](../../../img/uploads/dd8578d089a94f2c8c30dfc11ced4023.png)]</figure>\n<!-- /wp:image -->\n\n<!-- wp:list -->\n\n*   Installiere die Datei wie eine gewöhnliche Software, z. B. über Windows per Doppelklick auf die Datei \"python-3-6-2.exe\". Aktiviere die Auswahl \"Add Python 3.6 to PATH\" im ersten Installationsfenster!! Weitere Anpassungen musst du nicht durchführen. Im nächsten Schritt wird die Installation durchgeführt und du kannst den Installer verlassen.\n<!-- /wp:list -->\n\n<!-- wp:image {\"id\":17,\"align\":\"center\",\"linkDestination\":\"media\",\"className\":\"imagedropshadow\"} -->\n<div class=\"wp-block-image imagedropshadow\">\n<figure class=\"aligncenter\">[![Python Installation](../../../img/uploads/91bac29adbe6441d8686448035ff40cb.png)</figure>\n</div>\n<!-- /wp:image -->\n\n<!-- wp:list -->\n\n*   Wenn Python richtig installiert wurde, kannst du die Python-Installation aus Schritt 2 noch einmal prüfen und solltest diesmal erfolgreich sein.\n<!-- /wp:list -->",
      "title": "Mit dem Terminal arbeiten und Python installieren\t\t",
      "date": "2017-07-28",
      "createdAt": "2020-04-11T08:40:33.792Z",
      "updatedAt": "2020-04-11T08:55:12.356Z",
      "__v": 0,
      "slug": "mit-dem-terminal-arbeiten-und-python-installieren",
      "id": "5e918281de6c310010be67c2"
    },
    {
      "category": "tutorial",
      "_id": "5e918653de6c310010be67c7",
      "html": "<!-- wp:paragraph -->\n\nIn diesem Tutorial geht es darum, einen einfachen Webserver auf Node.js-Basis zu installieren und zu testen. Dieses Tutorial ist im Rahmen der Bremer [SummerSchool \"Informatica Feminale\"](https://www.informatica-feminale.de/) für den Kurs \"Einführung in die modere Webentwicklung\" (2018) entstanden.\n\n<!-- /wp:paragraph -->\n\n<!-- wp:more -->\n\n<!--more-->\n\n<!-- /wp:more -->\n\nFür eine Anleitung zur Installation von Node.js und npm in Vorbereitung auf das Setup des Express.js-Servers, gibt es [hier](https://rike.dev/2019/06/18/node-js-und-npm-installieren/) das entsprechende Tutorial.\n\n<!-- wp:heading -->\n\n## Den Webserver einrichten / Express.js installieren\n\n<!-- /wp:heading -->\n\n<!-- wp:list -->\n\n*   Lege auf deinem Computer einen Ordner an, in dem du während des Kurses arbeiten möchtest. Den Ort kannst du beliebig festlegen.\n*   Innerhalb dieses Ordners lege zwei neue Dateien an (in Windows z. B. per Rechtsklick: \"Neues Textdokument\")!\n*   Benenne eine Datei um in \"server.js\", die andere in \"index.html\". (In Windows solltest du sicher gehen, dass sich die Dateiendung mitändert, und nicht etwa eine Datei nach dem Schema \"server.js.txt\" und \"index.html.txt\" entstanden ist!)\n*   Navigiere im Terminal zum neu angelegten Ordner. Der Befehl dazu lautet \"cd\" gefolgt vom entsprechenden Pfad. Für ein Windows-System könnte der Befehl so lauten: <!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\">cd C:\\Users\\Ulrike\\Projekte\\Neues-Projekt1</pre>\n<!-- /wp:preformatted --> Für ein macOS-System wäre dies ein Beispiel-Befehl: <!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\">cd /Volumes/PROJECTS/Neues-Projekt1</pre>\n<!-- /wp:preformatted --> Wenn du erfolgreich warst, wird der Pfad, in dem du dich nun befindest, der neuen Kommandozeile voran gestellt.\n*   Installiere in diesem Ordner das _npm_-Paket \"Express.js\", den de-Facto-Standard für Webanwendungen unter Node.js mit dem Terminal-Befehl\n<!-- /wp:list -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\">npm install express</pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:list -->\n\n*   Öffne die Datei \"server.js\" in einem Texteditor (z. B. \"Sublime\") und füge diesen Quellcode ein:\n<!-- /wp:list -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\">const express = require('express');\nconst app = express();\n\napp.use(express.static(__dirname + '/dist'));\n\napp.get('/', function (req, res) {\nres.sendFile(__dirname + '/index.html');\n})\n\napp.get('/about', function (req, res) {\nres.sendFile(__dirname + '/about.html');\n})\n\napp.listen(3000);\nconsole.log(\"server started on port 3000\");</pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:list -->\n\n*   Öffne die Datei \"index.html\" und füge einen beliebigen Text ein, z. B. \"Hello World!\". Optional kannst du eine weitere Datei \"about.html\" erstellen und diese mit Leben füllen.\n*   Jetzt müssen wir unseren Webserver nur noch starten. Im Quellcode haben wir ihn bereits angewiesen, die Datei _index.html _auszugeben.\n<!-- /wp:list -->\n\n<!-- wp:heading -->\n\n## Den Webserver starten\n\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n\nPrüfe noch einmal, ob du dich in deinem Terminal im richtigen Dateipfad befindest. Wenn ja, gib ins Terminal den folgenden Befehl ein:\n\n<!-- /wp:paragraph -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\">node server.js</pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:paragraph -->\n\nNavigiere in deinem Browser zur URL [http://127.0.0.1:3000/ ](http://127.0.0.1:3000/)oder [http://localhost:3000/](http://localhost:3000/). Wenn alles geklappt hat, wird dort nun der Inhalt des von dir angelegten HTML-Dokuments angezeigt, also z. B. \"Hello World\".\n\nIn diesem Beispiel-Tutorial übernimmt unser Server das Handling der Routen (z. B. /about) für uns. Wir könnten den Server auch noch weitere Aufgaben erfüllen lassen, z. B. die Anbindung einer Datenbank.\n\nEin Beispiel zum Ausliefern einer statischen Website durch Express.js findest du [hier](https://rike.dev/2019/06/18/express-js-statische-website/).\n\n<!-- /wp:paragraph -->\n\n<!-- wp:heading -->\n\n## Den Webserver stoppen\n\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n\nDen gestarteten Webserver kannst du jederzeit wieder stoppen. Dann ist er nicht mehr unter der URL http://127.0.0.1:3000/ erreichbar. Im Terminal musst du dazu lediglich [Strg] + [C] bzw. [Ctrl] + [C] drücken.\n\n<!-- /wp:paragraph -->",
      "title": "Node.js installieren und einen Webserver starten",
      "slug": "node-js-installieren-und-einen-webserver-starten",
      "date": "2018-07-15",
      "createdAt": "2020-04-11T08:56:51.093Z",
      "updatedAt": "2020-04-11T08:56:51.093Z",
      "__v": 0,
      "id": "5e918653de6c310010be67c7"
    },
    {
      "category": "tutorial",
      "_id": "5e9186e8de6c310010be67c8",
      "html": "<p class=\"intro\">This tutorial is the second part of the series \"[How To: Smart Home setup to track indoor temperatures and humidity with sensors, Raspberry Pi, MQTT, Node.js, Vue.js and Chart.js](/2019/02/11/smart-home-setup-to-track-indoor-temperatures-and-humidity-with-sensors-raspberry-pi-mqtt-node-js-vue-js-and-chart-js)\" ([1](/2019/02/11/hardware-sensors-receiver-raspberry-pi-for-a-basic-tracking-tool-on-temperature-and-humidity)&nbsp;'&nbsp;[2](/2019/02/07/smart-home-sensor-data-with-mqtt-broker-mosquitto-and-a-node-js-backend-application)&nbsp;'&nbsp;3)</p>\n\nIn this part we will build a basic dashboard displaying smart home sensor data with charts.&nbsp;We could go with whatever implementation you would like here: from vanilla HTML/CSS/JS to every framework which is suitable to our needs - which are basically doing an API call to our backend to fetch sensor data and lift them up to work nicely with a chart visualisation.&nbsp; There are also other good solutions to deal with IoT frontends like Pimatic, OpenHAB and FHEM, but let's just build this part completely on our own.&nbsp;We will go with the SPA framework Vue.js with Quasar on top: It comes with UI components in the popular Material Design, axios and some other features, that help getting started with Vue.js very fast.\n\nInstall the Vue.js ([Link](https://vuejs.org/)) and Quasar CLI ([Github link](https://github.com/quasarframework/quasar)) first!\n<pre class=\"code\">npm install -g vue-cli\nnpm install -g quasar-cli</pre>\nGo to your project root and init a new sub project for your frontend code with\n<pre class=\"code\">quasar init vue-frontend</pre>\nNow start you development server on http://localhost:8080/ with\n<pre class=\"code\">quasar dev</pre>\nand you are ready to develop your frontend according to your likes. Quasar comes with a basic starter layout including a side navigation. However we don't need to work on this heavily and focus on the homepage, where we will build the dashboard functionality.\n\nGo to _Index.vue_ and update the basic dashboard layout. You can use static images like in my proposal and put them into the _src/assets_ folder.\n\n![Code](../../../img/uploads/6f3b27872fe74a6b89c0b43b5ea90265.png)\n\n![Dashboard](../../../img/uploads/973e15a752b844b89347973a9cb998dc.png)\n\n##### Fetch sensor data from Node.js backend\n\nTo fetch necessary data on initial page load we make use of Vue.js' created() function in the <script></script> section below the template. We insert a new function this.fetchData(); there and implement this new function in the methods' block.\n\n<pre class=\"code\"> methods: {\n  fetchData() {\n   this.loaded = false;\n   this.$axios\n    .get(\"http://localhost:3000/api\")\n    .then(response => {\n       return response.data;\n    })\n    .then(response => {\n      console.log(response);\n      this.loaded = true;\n    })\n    .catch(e => {\n      console.log(e);\n      this.$q.notify({\n       color: \"negative\",\n       position: \"top\",\n       message: \"Could not fetch.\",\n       icon: \"report_problem\"\n    });\n  });\n }\n}</pre>\nWe simply use the _axios_ library ([Github link](https://github.com/axios/axios)) which Quasar included right from the setup, so we can use it globally without importing it explicitly. If this works properly you should be able to log the array of sensor data in your browser's developer tools. If there is any problem, we trigger&nbsp;the Quasar component notification and include the error message.\n\n**Hint:** If you encounter _CORS_ problems in the communication between front- and backend (e. g. \"No Access-Control-Allow-Origin header is present on the requested resource.\") edit your_ server.js_ and restart it as follows:\n<pre class=\"code\">app.use(function (req, res, next) {\n res.header(\"Access-Control-Allow-Origin\", \"*\");\n res.header(\"Access-Control-Allow-Headers\", \n    \"Origin, X-Requested-With, Content-Type, Accept\");\n next();\n});</pre>\n\n##### Build a line chart with Chart.js\n\nIn this part I will focus on displaying only the temperature chart to make the tutorial more comprehensable. At first we will install the npm package _vue-chartjs _[(Github link)&nbsp;](https://github.com/apertureless/vue-chartjs)which works as a practical Vue.js wrapper for Chart.js ([Link](https://www.chartjs.org/)).\n<pre class=\"code\">npm install vue-chartsjs --save</pre>\nNow we build a generic, reusable line chart component to use in the web application. Create a new file \"LineChart.js\" in the _src/components_ folder and import the _vue-chartsjs_ package. Furthermore, we will follow the basic tutorial for the package and specify a data collection prop and an options prop that will prettify our line chart later.\n<pre class=\"code\">\nimport { Line } from 'vue-chartjs';\nexport default {\n extends: Line,\n props: {\n   datacollection: {\n    type: Object,\n    default: null\n   },\n   options: {\n    type: Object,\n    default: null\n   }\n  },\n mounted() {\n   this.renderChart(this.datacollection, this.options, {responsive: true})\n }\n}</pre>\n\nSwitch to the_ Index.vue_ again and include a new line chart component (html tag) in your template.&nbsp;We want to display it within the card component. Additionally we specify some properties: _v-if=\"loaded\"_ will tell the component that it should only mount, if the according data prop is true. Also, we transfer the _fetched datacollection_humidity_ and _options_humidity_ as our generic datacollection and options into the line chart.\n\n![Code](../../../img/uploads/4519a16c52c64bf493739b0ca16c590f.png)\n\nWe also have to edit our fetchData(); function and transfer the fetched data as a processible JSON to the data collection prop.\n<pre class=\"code\">/ process the backend response and add labels and some styling for the Chart.js api  \nconst datacollection_humidity = {\n   labels: response.map(obj => obj.time),\n   datasets: [\n     {\n       label: \"Humidity\",\n       backgroundColor: \"#000\",\n       data: response.map(obj => obj.humidity)\n     }\n   ]\n};\nthis.datacollection_humidity = datacollection_humidity;\n// set some optional properties regarding axes and ticks\nthis.options_humidity = {\n   scales: {\n   xAxes: [\n     {\n       type: \"time\",\n       distribution: \"linear\"\n     }\n   ],\n   yAxes: [\n     {\n       scaleLabel: {\n       display: true\n     },\n   ticks: {\n     callback: function(value, index, values) {\n       return value + \"%\";\n       }\n     }\n    }\n   ]\n  }\n};</pre>\n\nDon't forget to add the LineChart component and the necessary \"loaded\" data prop in your Vue.js <script></script> section.\n\n<pre class=\"code\">export default {\n name: \"PageIndex\",\n components: {\n   LineChart\n   },\n data() {\n   return {\n     loaded: false,\n     };\n   }\n}</pre>\n\nThat's it! On every page reload, the web application fetches available sensor data from our backend service and will display it as a line chart. You would like to add more functionality? You can find all features we built and more (filtering, reloading, deploying, saving persistently, ..) in my [Github repository](https://github.com/gitfrosh/tiny-smart-home) for this project.",
      "title": "Display smart home data in a Quasar, Vue.js and Chart.js powered web application\t\t",
      "slug": "display-smart-home-data-in-a-quasar-vue-js-and-chart-js-powered-web-application",
      "date": "2019-02-11",
      "createdAt": "2020-04-11T08:59:20.135Z",
      "updatedAt": "2020-05-04T18:16:13.052Z",
      "__v": 0,
      "id": "5e9186e8de6c310010be67c8"
    },
    {
      "category": "tutorial",
      "_id": "5e9206ab3362d2001025ab19",
      "html": "<p class=\"intro\">This tutorial is part of the series \"[How To: Smart Home setup to track indoor temperatures and humidity with sensors, Raspberry Pi, MQTT, Node.js, Vue.js and Chart.js](/2019/02/11/how-to-smart-home-setup-to-track-indoor-temperatures-and-humidity-with-sensors-raspberry-pi-mqtt-node-js-vue-js-and-chart-js)\"&nbsp;(1&nbsp;'&nbsp;[2](/2019/02/07/smart-home-sensor-data-with-mqtt-broker-mosquitto-and-a-node-js-backend-application/)&nbsp;'&nbsp;[3](/2019/02/11/display-smart-home-data-in-a-quasar-vue-js-and-chart-js-powered-web-application))</p>\n\n##### Which (new) IoT hardware do&nbsp;we need for this setup?\n\n*   **RTL-SDR USB receiver:**&nbsp;a cheap&nbsp;dongle&nbsp;that can be used as a computer based radio scanner for receiving live radio signals in your area (those gagdets receive signals from 500 kHz up to 1.75 GHz) ([Amazon link](https://www.amazon.com/dp/B00VZ1AWQA/ref=cm_sw_em_r_mt_dp_U_GkvyCb5A4PD19))\n*   **Temperature / Humidity sensor:** an even cheaper gagdet, that sends sensor data at 433 MHz into the area (e.g. as part of a \"real\" wheather station) ([Amazon link](https://www.amazon.de/gp/product/B01MXEBI18/ref=ppx_yo_dt_b_asin_title_o05__o00_s00?ie=UTF8&psc=1))\n*   **Raspberry Pi 3 Model B:** the&nbsp;small&nbsp;single-board computer&nbsp;servers as our heart and base station to receive and process sensor data, I have the Raspbian operating system installed. It could even serve as your web server later (if you are familiar with maintaining your own, but I will use a cloud service in this tutorial). ([Amazon link](https://www.amazon.com/Raspberry-Pi-RASPBERRYPI3-MODB-1GB-Model-Motherboard/dp/B01CD5VC92/ref=sr_1_3?ie=UTF8&qid=1549882307&sr=8-3&keywords=Raspberry+Pi+3+Model+B))\nAt first, setup your sensors whereever you like in your appartment and connect your RTL-SDR receiver with the Raspberry Pi. How to receive the raw data out of the nearby area? A little open source software will help us with that: _rtl_433_ is a program ([Github link](https://github.com/merbanan/rtl_433)) to decode traffic from devices that are broadcasting on 433.9 MHz. We install it on our Raspberry Pi:\n\n<pre class=\"code\">\nsudo apt-get update\nsudo apt-get upgrade\n# install dependencies\nsudo apt-get install libtool libusb-1.0.0-dev librtlsdr-dev rtl-sdr cmake\n# clone rtl_433 Git Repository\ngit clone https://github.com/merbanan/rtl_433.git\n# change to directory\ncd rtl_433/\n# make build folder\nmkdir build\ncd build/\n# compile\ncmake ../\n# make\nmake\n# install\nsudo make install\n# test if rtl_433 was properly installed\nrtl_433 -h\n</pre>\n\nAfter that we test if the program detects our RTL-SDR receiver with\n<pre code\">rtl_433&nbsp;-G</pre>\nI had some trouble with the following error:&nbsp;_Kernel driver is active, or device is claimed by second instance of librtlsdr.&nbsp;__In the first case, please either detach or blacklist the kernel module&nbsp;__(dvb_usb_rtl28xxu), or enable automatic detaching at compile time._\n\nThe repository owner recommends\n<pre class=\"code\">sudo&nbsp;rmmod&nbsp;dvb_usb_rtl28xxu&nbsp;rtl2832</pre>\nin that case. If everything went well, the receiver is ready to get sensor data and_ rtl_433_ helps with processing, so that after a few seconds you should get signals in the nearby area (yes, even temperature sensor data of your neighbor's or sensor data of connected cars.)\n\n![Code](../../../img/uploads/11b0f646239547b7b4b115dcd2e12104.png)\n\n![Code](../../../img/uploads/aa1627243d4f488f9df5fa730a719d69.png)\n\nHurray, hardware is running!\n\n* * *\n\nProceed to the second part of the tutorial \"[Get&nbsp;and process your smart home sensor data with MQTT Broker Mosquitto and a Node.js backend](/2019/02/07/smart-home-sensor-data-with-mqtt-broker-mosquitto-and-a-node-js-backend-application/)\".",
      "title": "Choose and setup hardware (sensors, receiver, Raspberry Pi) for a basic tracking tool on temperature and humidity\t\t",
      "slug": "hardware-sensors-receiver-raspberry-pi-for-a-basic-tracking-tool-on-temperature-and-humidity",
      "date": "2019-02-11",
      "createdAt": "2020-04-11T18:04:27.900Z",
      "updatedAt": "2020-05-03T09:37:33.520Z",
      "__v": 0,
      "id": "5e9206ab3362d2001025ab19"
    },
    {
      "category": "tutorial",
      "_id": "5e920a2d3362d2001025ab1a",
      "html": "<p class=\"intro\">This tutorial is the second part of the series \"[How To: Smart Home setup to track indoor temperatures and humidity with sensors, Raspberry Pi, MQTT, Node.js, Vue.js and Chart.js](/2019/02/11/smart-home-setup-to-track-indoor-temperatures-and-humidity-with-sensors-raspberry-pi-mqtt-node-js-vue-js-and-chart-js)\"&nbsp;([1](/2019/02/11/hardware-sensors-receiver-raspberry-pi-for-a-basic-tracking-tool-on-temperature-and-humidity)&nbsp;'&nbsp;2&nbsp;'&nbsp;[3](/2019/02/11/display-smart-home-data-in-a-quasar-vue-js-and-chart-js-powered-web-application))</p>\n\nThe main problem&nbsp;in this part is how to setup a stable and endlessly running task on&nbsp;a Raspberry Pi to continuously receive the (correct!) sensor data. Secondly&nbsp;we want it to somehow process and transfer it&nbsp;to a service that works as our middleware to provide the frontend with JSON data to display. MQTT is the IoT protocol to go with but how can a MQTT broker like Mosquitto work with a Node.js backend properly?\n\n##### Setup a web server backend with Node.js and Express.js\n\nMultiple solutions would be possible here, but I decided for a Javascript Node.js backend which will be running with Express.js. Make sure _node_ and _npm_ are ready on your machine or install them first.\n<pre class=\"code\">\nnode -v\nnpm -v</pre>\nSetup a project folder and a make a subfolder \"server\". Create a new file \"server.js\" within and code a basic backend service. We will upgrade its functionality later.\n<pre class=\"code\">\nconst express = require('express');\nconst app = express();\n// test\napp.get('/', function (req, res) {\n res.send('hello world!');\n});\napp.listen(3000, () => console.log('App listening on port ', 3000));\n</pre>\n\nDon't forget to install the _npm_ package_ express_ in your console and start the application! (Don't know&nbsp;how Node.js with Express.js works? Check out e.g.&nbsp;[this tutorial](https://www.guru99.com/node-js-express.html).)\n\n<pre class=\"code\">\nnpm init\nnpm install express --save\nnode server.js</pre>\nGo to your browser and check if your&nbsp;web server works on http://localhost:3000.\n\n##### Setup the MQTT broker Mosquitto\n\nWhy MQTT? The protocol is a lightweight publish/subscribe messaging transport solution which is very popular in the IoT field. We will use a MQTT broker as the control center to receive raw sensor data from our *rtl_433 program*, we installed in the previous chapter and forward them to our web server. Mosquitto is a common MQTT broker and is installed and tested on or Raspberry Pi with\n<pre class=\"code\">\nsudo apt install -y mosquitto mosquitto-clients\nmosquitto -v</pre>\nThe broker will be accessable to clients on mqtt://localhost:1883.\n\n##### Setup a bash script that pipes incoming data to Mosquitto\n\nThe Raspberry Pi now gets the important task to not only start *rtl_433* to decode traffic from devices that are broadcasting on 433.9 MHz manually, but to start this task on every reboot automatically. For that, we create a cronjob with the tool *crontab*, which should be installed on&nbsp;our&nbsp;system.\n<pre class=\"code\">crontab -h</pre>\nOn your Raspberry Pi create a new file *tsh_raspberry_script.sh* (or whatever you want) in your _pi_&nbsp;home folder and make it executable from your terminal:\n<pre class=\"code\">chmod +x tsh_raspberry_script.sh</pre>\nAfter that, open the file in a text editor and add the following bash script. It will start *rtl_433* and pipe the output in JSON format to Mosquitto, where it will be published in the topic *home/rtl_344*. Don't forget to close and safe the file.\n<pre class=\"code\">\n#!bin/bash\n/usr/local/bin/rtl_433 -F json -M utc ' mosquitto_pub -t home/rtl_433 -l</pre>\nNow we can set up a new cronjob which will execute the shell script on every Raspberry Pi reboot. Open up a terminal:\n<pre class=\"code\">\n# edit crontabs of user \"pi\"\ncrontab -e\n# a text editor will open and load all existing cronjobs, add\n@reboot sleep 60 &&&nbsp;sh&nbsp;/home/pi/tsh_raspberry_script.sh</pre>\n\n##### Build a simple database with lowdb and Node.js\n\nIn development mode a very basic database will suffice our requirements, that's why I used _lowdb _[(Github link)](https://github.com/typicode/lowdb) to store the sensor data on localhost first. Lowdb is based on a JSON file in&nbsp;our project folder. If you would like to take an eye on performance and persistence later I have built a solution with PostgreSQL too, but this is [another story](/2019/04/20/setup-postgresql-database-and-api-for-node-js).\n<pre class=\"code\">\nnpm&nbsp;install&nbsp;lowdb&nbsp;--save</pre>\nIn your _server.js_ add some code.&nbsp;Set some defaults first, which are required if your JSON file (mine is \"db.json\") is empty at first.\n<pre class=\"code\">const low = require('lowdb');\nconst FileSync = require('lowdb/adapters/FileSync')\nconst adapter = new FileSync('db.json');\nconst db = low(adapter);\ndb.defaults({ posts: [] })\n .write()</pre>\nThat's all. Now we can write into, edit and delete data within our database.\n\n##### Consume MQTT sensor data and save it to the database\n\nWe go back to our Node.js application and install the MQTT client _MQTT.js_ ([Github link](https://github.com/mqttjs/MQTT.js)) to be able to consume data that is available via Mosquitto.\n<pre class=\"code\">npm&nbsp;install&nbsp;mqtt&nbsp;--save</pre>\nWith the newly installed MQTT client we are able to receive all the messages that the MQTT broker delivers over its API on mqtt://localhost:1883. We now filter them to only process and store \"correct\" data sets (remember: our RTL-SDR receiver found signals from multiple IoT gagdets we are not interested in).\n\nMy setup included some buffer, temperature and date parsing, basic verifying and filtering regarding incoming messages before I stored the correct Javascript Objects into the lowdb. Continue working on your _server.js_:\n<pre class=\"code\">\nconst mqtt = require('mqtt');\nconst client = mqtt.connect(mqtt://localhost:1883);\nfahrenheitToCelsius = (fahrenheit) => {\n var fTempVal = parseFloat(fahrenheit);\n var cTempVal = (fTempVal - 32) * (5 / 9);\n return (Math.round(cTempVal * 100) / 100);\n}\nclient.on('message', function (topic, message) {\n // message is buffer\n var stringBuf = message && message.toString('utf-8')\n try {\n   var json = JSON.parse(stringBuf);\n   // console.log(json);\n   if (json.model === 'inFactory sensor') {\n     if (json.id === 91 '' json.id === 32) {\n     // catch my specific sensor model\n       if (json.temperature_F && json.humidity) {\n       // add data to lowdb\n       const time = moment.utc(json.time).tz(\"Europe/Berlin\");\n       const formattedTime = time.format('YYYY-MM-DD HH:mm:ss');\n       console.log('write post');\n       db.get('posts')\n       .push({ id: uuid.v1(), room: json.id, temp: \n            fahrenheitToCelsius(json.temperature_F), \n            humidity: json.humidity, time: formattedTime }).write()\n       }\n     }\n   }\n } catch (e) {\n   console.error(stringBuf);\n   }\n})</pre>\nThat's it. Whenever the MQTT client receives sensor data it will store it in our database accordingly. You can check that in your \"db.json\" file in your project folder, which grows bigger and bigger during runtime. It won't delete itself on backend restart!<pre class=\"code\">\n{\n \"posts\": [\n {\n \"id\": \"c107fc70-1f33-11e9-9b95-fbfea27c8046\",\n \"room\": 32,\n \"temp\": 22.89,\n \"humidity\": 30,\n \"time\": \"2019-01-23 18:24:34\"\n },\n {\n \"id\": \"6607f9f0-1f34-11e9-9b95-fbfea27c8046\",\n \"room\": 32,\n \"temp\": 22.89,\n \"humidity\": 30,\n \"time\": \"2019-01-23 18:29:11\"\n },\n {\n \"id\": \"16492190-1f35-11e9-9b95-fbfea27c8046\",\n \"room\": 91,\n \"temp\": 22.72,\n \"humidity\": 35,\n \"time\": \"2019-01-23 18:34:07\"\n }\n]\n}</pre>\n\n##### Provide sensor data via REST API\n\nNow that we have clean data in our lowdb we might want to provide them via a REST API to be consumable for a frontend or multiple frontends (smartphone app, web app, ..). We already deployed a local web server running on Node.js and Express.js and can very simply add an endpoint the provides the database data with the following code. Add it to your _server.js_!\n<pre class=\"code\">\napp.get('/api', (req, res) => {\n res.send(db.get('posts'));\n});</pre>\nYes, that's it. Check if it is working on http://localhost:3000/api or with your favourite REST client (e.g. Postman).\n\n* * *\n\n<p class=\"outro\">Proceed to the third part of the tutorial \"[Display smart home data&nbsp;in a Quasar, Vue.js and Chart.js powered web application](/2019/02/11/display-smart-home-data-in-a-quasar-vue-js-and-chart-js-powered-web-application)\".</p>",
      "title": "Get and process your smart home sensor data with MQTT Broker Mosquitto and a Node.js backend application",
      "slug": "smart-home-sensor-data-with-mqtt-broker-mosquitto-and-a-node-js-backend-application",
      "date": "2019-02-07",
      "createdAt": "2020-04-11T18:19:25.892Z",
      "updatedAt": "2020-05-04T18:12:38.773Z",
      "__v": 0,
      "id": "5e920a2d3362d2001025ab1a"
    },
    {
      "category": "tutorial",
      "_id": "5e920d303362d2001025ab1c",
      "html": "<p class=\"intro\">**TLDR;** This three-part tutorial explains how to setup a basic smart home web app tracking sensor data for temperature and humidity with a Raspberry Pi and web technologies like Mosquitto, Node.js, Express.js, Vue.js, Quasar and Chart.js.</p>\n\n![Tiny Smart Home](../../../img/uploads/01741853357341038f43d5a2d33daa5a.png)\n\nSo I went on maternity this January and came up with an idea about a nice little project to do in my free time that went a little further from my usual Javascript front- und backend projects I usually do at work. I have a Raspberry Pi 3 at home I bought over a year ago and never did something useful with so I decided I wanted to track temperatures and humidity in our child's room and bedroom to a have an idea about a good indoor climate. In the end I wanted to finalize a cloud-based dashboard web app which provides the incoming sensor data in real time and available everywhere and everytime.\n\nI wrote this three-part tutorial to track my experiences, tech choices and suggestions for you to follow and came up with a solution that comes with an easy hardware setup and some popular (and worth to learn if you are not already familiar with) web development technologies, including Node.js, Mosquitto and Vue.js.\n\nThe basic three parts will allow you to run a web application on your local machine. Nevertheless I added some more features including persistent database storing and the deployment in the cloud with Heroku. You will find these tutorials at the end of this page.\n**The code base is stored on [Github](https://github.com/gitfrosh/tiny-smart-home)!**\n\n##### [Choose and install hardware (sensors, receiver, Raspberry Pi) for a basic tracking tool on temperature and humidity](/2019/02/11/hardware-sensors-receiver-raspberry-pi-for-a-basic-tracking-tool-on-temperature-and-humidity)\n\nI did some research on how to build basic weather stations and home automation systems with a Raspberry Pi but they were mostly no wireless solutions or they came up with too much IoT hacking/soldering and especially required a lot of electrical knowledge I do not have. The core problem I figured out was that many tutorials wanted me to build a remote sensor gagdet with radio functionality and sleep mode (e.g. with an Arduino) all on my own. So the question was: Is there a better and easier alternative to such an all self made solution and what about the receiving hardware on the Raspberry Pi?\n\nFortunately, there exists an easier alternative I will show you in this part of the tutorial which deals with slightly more expensive IoT gagdets but which enabled me to set up my smart home hardware in a smooth but nonetheless instructive way.\n\n##### [Get and process your smart home sensor data with MQTT Broker Mosquitto and a Node.js backend](/2019/02/07/smart-home-sensor-data-with-mqtt-broker-mosquitto-and-a-node-js-backend-application)\n\nThe main problem in this part was how to set up a stable and endlessly running task on my Raspberry Pi to continuously receive the (correct!) sensor data. Secondly I wanted it to somehow process and transfer it to a backend/microservice/middleware, which then would provide an upcoming frontend with JSON data to display. MQTT is the IoT protocol to go with but how to set it up? How can a MQTT broker like Mosquitto work with a Node.js backend properly?\n\n##### [Display smart home data in a Quasar, Vue.js and Chart.js powered web application](/2019/02/11/display-smart-home-data-in-a-quasar-vue-js-and-chart-js-powered-web-application)\n\nThis was somehow the easiest part, because I mainly work as a frontend engineer and know how to implement dashboard-like web app solutions in combination with backend REST API services and the like. I challenged myself with an insight into Vue.js, since I mainly used React as a SPA framework before. In search of a nice UI library I discovered Quasar, which provides a very useful CLI and UI components so that there was no need to come up with an own CSS by myself.\n\n* * *\n\n#####  Add more features?\n\nI wrote some more or less standalone tutorials, which will help you to improve your existent application with some more capacities.\n\n1.  Deploy your smart home application up to the cloud on Heroku _(coming soon)_\n2.  <div>Build a simple session-based authentication with Node.js and Vue.js _(coming soon)_</div>\n3.  <div>[Setup PostgreSQL database and API for Node.js](/2019/04/20/setup-postgresql-database-and-api-for-node-js)</div>\n4.  [Get a CSV download out of PostgreSQL or lowdb database on Node.js](/2019/04/20/get-a-csv-download-out-of-postgresql-or-lowdb-database-on-node-js)",
      "title": "How To: Smart Home setup to track indoor temperatures and humidity with sensors, Raspberry Pi, MQTT, Node.js, Vue.js and Chart.js",
      "slug": "smart-home-setup-to-track-indoor-temperatures-and-humidity-with-sensors-raspberry-pi-mqtt-node-js-vue-js-and-chart-js",
      "date": "2019-02-11",
      "createdAt": "2020-04-11T18:32:16.249Z",
      "updatedAt": "2020-05-05T21:29:05.746Z",
      "__v": 0,
      "id": "5e920d303362d2001025ab1c"
    },
    {
      "category": "tutorial",
      "_id": "5e920f1c3362d2001025ab1d",
      "html": "<p class=\"intro\">This small tutorial provides a solution to provide a download link for your website users to fetch a csv file including the data out of a PostgreSQL or lowdb database. Have fun! It's also part of the series \"[How To: Smart Home setup to track indoor temperatures and humidity with sensors, Raspberry Pi, MQTT, Node.js, Vue.js and Chart.js](/2019/02/11/smart-home-setup-to-track-indoor-temperatures-and-humidity-with-sensors-raspberry-pi-mqtt-node-js-vue-js-and-chart-js)\"</p>\n\nAt first we create a basic Node.js application with Express.js and setup and connect to PostgreSQL or lowdb database. Make sure your PostgreSQL database is accessable on port 5432!\n<pre class=\"code\">// import Express.js\nconst express = require('express');\nconst app = express();\n// import lib needed for csv download in lowdb\nconst jsonexport = require('jsonexport');\n// connect to lowdb\nconst low = require('lowdb');\nconst adapter = new FileSync('db.json');\nconst db = low(adapter);\n// connect to PostgreSQL db\nconst Pool = require('pg').Pool;\nlet pool;\ntry {\n    pool = new Pool({\n      user: 'postgres',\n      host: 'localhost',\n      database: 'whatever-db-name',\n      password: 'password',\n      port: 5432,\n    })\n    pool.query(\"CREATE TABLE IF NOT EXISTS posts (id VARCHAR(100) PRIMARY KEY, room INT, temp VARCHAR(30), humidity VARCHAR(30), time VARCHAR(100))\");\n  } catch (e) {\n    console.log(e)\n  }\n// setup Express web app\napp.listen(port, () => console.log('App listening on port ', port));</pre>\n\nThen we create a new endpoint providing a csv download of the lowdb database:\n\n<pre class=\"code\">\n// download CSV\napp.get('/lowdb-download', function (req, res) {\n  try {\n    var reader = fs.createReadStream('db.json');\n    var writer = fs.createWriteStream('db.csv');\n    var pipe = reader.pipe(jsonexport()).pipe(writer);\n  } catch (e) {\n    console.log(e)\n  }\n});</pre>\n\nOr, if you use a PostgreSQL database this snippet works:\n\n<pre class=\"code\">/app.get('/postgres-download', function (req, res) {\n  try {\n    var writer = fs.createWriteStream('db.csv');\n    pool.connect(function (pgErr, client, done) {\n      var stream = client.query(copyTo('COPY posts TO STDOUT'));\n      var pipe = stream.pipe(writer);\n      pipe.on('finish', function () {\n        var stream = fs.createReadStream('db.csv');\n        res.attachment('db.csv');\n        stream.pipe(res);\n      });\n    })\n  } catch (e) {\n    console.log(e)\n  }\n});</pre>\n\nNow start your app with `node server.js` and check your implementation on http://localhost:3000/postgres-download and http://localhost:3000/lowdb-download. Your browser should start the download automatically.",
      "title": "Get a CSV download out of PostgreSQL or lowdb database on Node.js\t",
      "slug": "get-a-csv-download-out-of-postgresql-or-lowdb-database-on-node-js",
      "createdAt": "2020-04-11T18:40:28.489Z",
      "updatedAt": "2020-05-03T09:47:25.879Z",
      "__v": 0,
      "date": "2019-04-20",
      "id": "5e920f1c3362d2001025ab1d"
    },
    {
      "category": "tutorial",
      "_id": "5e920fee3362d2001025ab1e",
      "html": "<p class=\"intro\">In this short tutorial we will setup a Node.js application with a connection to a PostgreSQL database and provide data via API endpoint. It's also part of the series \"[How To: Smart Home setup to track indoor temperatures and humidity with sensors, Raspberry Pi, MQTT, Node.js, Vue.js and Chart.js](/2019/02/11/smart-home-setup-to-track-indoor-temperatures-and-humidity-with-sensors-raspberry-pi-mqtt-node-js-vue-js-and-chart-js)\"</p>\n\nAt first, follow the [official online documentation](http://www.postgresqltutorial.com/install-postgresql/) on how to install a PostgreSQL database system on your OS. On a Linux machine, you might do something like this:\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\">sudo apt-get update\nsudo apt-get install postgresql postgresql-contrib</pre>\nThis installation comes with _psql, _a terminal-based front-end to PostgreSQL. Access to the (still empty) database system is provided with:\n<pre class=\"code\"> sudo -u postgres psql</pre>\nCreate a new database with the name \"tshtest\", list all available databases and connect to \"tsh\":\n<pre class=\"code\"> \npostgres=# CREATE DATABASE tshtest;\npostgres=# \\list\npostgres=# \\c tsh</pre>\n\nFrom here you could create tables to store data, but it is also possible to do that from our Node.js application later. _So here we go:_ Our Node.js application won't do anything more than handle our database requests from a (non-existing) frontend. You can test all API calls with a client like [Postman](https://www.getpostman.com/) or even just your browser. The next code snippet provides our basic Node.js (with Express.js) boilerplate already including the [_node-postgres_ library](https://www.npmjs.com/package/pg), the propably best client for Node.js. Because we are working on a web application which makes frequent queries we use a connection pool. The easiest and by far most common way to use node-postgres is through a connection pool.\n<pre class=\"code\"> \nconst express = require('express');\nconst app = express();\nconst uuid = require('uuid');\nconst Pool = require('pg').Pool;\nconst port = 3000;\napp.listen(port, () => console.log('App listening on port ', port));</pre>\n\nThe connection pool is triggered with the following code snippet. This code also checks on every server start, if the table \"posts\" is already existing. If not, it will be created. Right after that we will insert a first example post. If the SQL syntax is new to you, you can check out [this great tutorial](https://beginner-sql-tutorial.com/sql.htm) to know what's going on here.\n<pre class=\"code\"> \nlet pool;\ntry {\n    pool = new Pool({\n      user: 'postgres',\n      host: 'localhost',\n      database: 'tshtest',\n      password: 'password',\n      port: 5432,\n    })\n    pool.query(\"CREATE TABLE IF NOT EXISTS posts (id VARCHAR(100) PRIMARY KEY, room INT, temp VARCHAR(30), humidity VARCHAR(30), time VARCHAR(100))\");\n    pool.query('INSERT INTO posts (id, room, temp, humidity, time) VALUES ($1, $2, $3, $4, $5)', [uuid.v1(), 1, 30, 40, 2019-04-20], (error, results) => {\n        if (error) {\n          throw error\n        } else {\n          console.log(results);\n        }\n    })\n} catch (e) {\n    console.log(e)\n}</pre>\n\nIt's time to open up a new endpoint on _/getData_, which will fetch all posts from the table \"posts\" in the database \"tshtest\".\n<pre class=\"code\"> \napp.get('/getData', (req, res) => {\n    pool.query('SELECT * FROM posts', (error, results) => {\n      if (error) {\n        throw error\n      }\n      res.status(200).json(results.rows)\n    })\n});</pre>\n\nJust for fun I add another endpoint _/deleteData_, which will delete all data from the database if called (be careful with that one ;)).\n\n<pre class=\"code\"> \napp.get('/deleteData', (req, res) => {\n    try {\n      pool.query(\"TRUNCATE TABLE posts\");\n      res.end('Deleted data!');\n    } catch (e) {\n      res.send(e);\n      console.error(e);\n    }\n});</pre>\n\nStart you web app with `node server.js` and check the endpoint http://localhost:3000/getData, which works also just right out of every browser and displays all database entries in JSON format.",
      "title": "Setup PostgreSQL database and API for Node.js",
      "slug": "setup-postgresql-database-and-api-for-node-js",
      "date": "2019-04-20",
      "createdAt": "2020-04-11T18:43:58.970Z",
      "updatedAt": "2020-05-03T09:44:44.902Z",
      "__v": 0,
      "id": "5e920fee3362d2001025ab1e"
    },
    {
      "category": "tutorial",
      "_id": "5e9210833362d2001025ab1f",
      "html": "<p class=\"intro\">In diesem Tutorial geht es darum, einen einfachen Webserver auf Express.js-Basis zu installieren und zu testen. Dieses Tutorial ist im Rahmen der Bremer [SummerSchool \"Informatica Feminale\"](https://www.informatica-feminale.de/) für den Kurs \"Einführung in die modere Webentwicklung\" (2019) entstanden.</p>\n\n\nFür eine Anleitung zur Installation von Node.js und npm in Vorbereitung auf das Setup des Express.js-Servers, gibt es [hier]/2019/06/18/node-js-und-npm-installieren/) das entsprechende Tutorial.\n\n## Den Webserver einrichten / Express.js installieren\n\n*   Lege auf deinem Computer einen Ordner an, in dem du während des Kurses arbeiten möchtest (z. B. \"Neues-Projekt1\"). Den Ort kannst du beliebig festlegen.\n*   Innerhalb dieses Ordners lege eine neue Datei an (in Windows z. B. per Rechtsklick: \"Neues Textdokument\") mit dem Namen \"server.js\".\n*   Innerhalb des gleichen Ordners lege einen neuen Unterordner an mit dem Namen \"public\". Darin erzeugst du eine neue Datei \"index.html\".\n*   (In Windows solltest du sicher gehen, dass sich die Dateiendung mitändert, und nicht etwa eine Datei nach dem Schema \"server.js.txt\" und \"index.html.txt\" entstanden ist!)\n*   Navigiere im Terminal zum neu angelegten Ordner (z. B. \"Neues-Projekt1\"). Der Befehl dazu lautet \"cd\" gefolgt vom entsprechenden Pfad. _Den Dateipfad kannst du in Windows mit einem Rechtsklick auf den Ordner unter \"Eigenschaften\" herausfinden._ Für ein Windows-System könnte der Befehl so lauten:\n<pre class=\"code\">cd C:\\Users\\Ulrike\\Projekte\\Neues-Projekt1</pre>\nFür ein macOS-System wäre dies ein Beispiel-Befehl:\n<pre class=\"code\">cd /Volumes/PROJECTS/Neues-Projekt1</pre>\nWenn du erfolgreich warst, wird der Pfad, in dem du dich nun befindest, der neuen Kommandozeile voran gestellt.\n*   Installiere in diesem Ordner das _npm_-Paket \"Express.js\", den de-Facto-Standard für Webanwendungen unter Node.js mit dem Terminal-Befehl\n<pre class=\"code\">npm install express</pre>\n\n*   Während des Installationsprozesses könnten gelb markierte \"Warnings\" erscheinen; diese kannst du ignorieren.\n*   Öffne die Datei \"server.js\" in einem Texteditor (z. B. \"Sublime\"), füge diesen Quellcode ein und speichere die Datei:\n<pre class=\"code\">const express = require(\"express\");\nconst app = express();\napp.use(express.static('public'));\napp.listen(3000);\nconsole.log(\"Server started on port 3000\");</pre>\n\n*   Öffne die Datei \"index.html\" im Unterordner \"public\" im Editor, füge einen beliebigen Text ein, z. B. \"Hello World!\" und speichere die Datei.\n*   Jetzt müssen wir unseren Webserver nur noch starten. Im Quellcode haben wir ihn bereits angewiesen, die Datei _index.html _auszugeben.\n\n## Den Webserver starten\n\nPrüfe noch einmal, ob du dich in deinem Terminal im richtigen Dateipfad (im Beispiel \"..\\Neues-Projekt1\") befindest. Wenn ja, gib ins Terminal den folgenden Befehl ein:\n<pre class=\"wp-block-preformatted\">node server.js</pre>\nNavigiere in deinem Browser zur URL [http://127.0.0.1:3000/ ](http://127.0.0.1:3000/)oder [http://localhost:3000/](http://localhost:3000/). Wenn alles geklappt hat, wird dort nun der Inhalt des von dir angelegten HTML-Dokuments angezeigt, also z. B. \"Hello World\".\n\n## Den Webserver stoppen\n\nDen gestarteten Webserver kannst du jederzeit wieder stoppen. Dann ist er nicht mehr unter der URL http://127.0.0.1:3000/ erreichbar. Im Terminal musst du dazu lediglich [Strg] + [C] bzw. [Ctrl] + [C] drücken.",
      "title": "Einen Webserver einrichten (2): Express.js für eine statische Website installieren\t",
      "createdAt": "2020-04-11T18:46:27.983Z",
      "updatedAt": "2020-04-11T18:50:24.211Z",
      "__v": 0,
      "slug": "express-js-statische-website",
      "date": "2019-06-18",
      "id": "5e9210833362d2001025ab1f"
    },
    {
      "category": "tutorial",
      "_id": "5e92115c3362d2001025ab20",
      "html": "<p class=\"intro\">In diesem Tutorial geht es darum, Node.js und npm als Vorbereitung für das Setup eines eigenen kleinen Webservers zu installieren. Dieses Tutorial ist im Rahmen der Bremer [SummerSchool \"Informatica Feminale\"](https://www.informatica-feminale.de/) für den Kurs \"Einführung in die modere Webentwicklung\" (2019) entstanden.</p>\n\n### Was ist Node.js?\n\n_Node.js_ ist eine Softwareumgebung für Javascript, welche es ermöglicht, serverseitige Javascript-Anwendungen (-> Webserver) auf einem beliebigen Betriebssystem zu programmieren. Sie erweitert \"klassisches\" Javascript um die notwendigen Funktionen und ist dabei extrem ressourcenschonend. Wofür brauchen wir **npm**? Mit dem Node Package Manager können wir die Kernfunktionalität von _Node.js_ über Zusatzpakete erweitern. Entwickler aus der ganzen Welt stellen ihre Pakete dort kostenlos zur Verfügung.\n\n### Node.js installieren\n\n##### Windows 7/8/10\n\nFür Windows stellt die offizielle _Node.js_-Website für die jeweiligen Versionen zur Verfügung: [https://nodejs.org/en/download/](https://nodejs.org/en/download/). Lade die richtige Datei (.msi) herunter und starte den Installer mit einem Doppelklick. Der Wizard wird dich durch den sehr kurzen Installationsprozess begleiten. Wähle während der Installation die Standardeinstellungen. _npm_ wird hier glücklicherweise gleich mitinstalliert.\n\n##### MacOS\n\nÜber die offizielle _Node.js_-Website kannst du den Installer (.pkg) für Node.js herunterladen: [https://nodejs.org/en/download/](https://nodejs.org/en/download/). Starte den Installer über deinen Mac und befolge die (kurzen) Installationsanweisungen. Wähle während der Installation die Standardeinstellungen. _npm_ wird hier glücklicherweise gleich mitinstalliert.\n\n##### Linux/Ubuntu\n\nIn Ubuntu kann _Node.js_ über die Paketverwaltung installiert werden. Da _npm_ nicht automatisch mitinstalliert wird, holen wir dies manuell nach.\n\n<pre class=\"code\">sudo apt-get update\nsudo apt-get install nodejs\nsudo apt-get install npm</pre>\n\n### Mit dem Terminal arbeiten / Die Installation von Node.js und npm prüfen\n\nMit dem Terminal können wir unser Betriebssystem textbasiert steuern. Häufigster Vorbehalt gegen das Terminal ist, dass es komplex und damit schwierig zu erlernen sei. Für einige Aufgaben ist er jedoch sehr gut geeignet, weswegen wir für dieses Tutorial / den Kurs ein wenig damit arbeiten werden.\n\n*   Öffne das Terminal (= Kommandozeile oder CLI oder Konsole) deines Betriebssystems:\n\n    *   In **Windows 8 und 10** geht das mit einem Klick mit der rechten Maustaste unten links im Bildschirm auf das Windows-Symbol oder mit der Tastenkombination [Windows] und [X]. Danach muss die \"Eingabeaufforderung\" oder die \"Eingabeaufforderung (Administrator)\" aus der Liste ausgewählt werden.\n    *   In **Windows 7** klickst du auf das Windows-Symbol links unten und suchst unter \"Dateien/Programme durchsuchen\" nach \"Eingabeaufforderung\".\n    *   In vielen **Linux**-Distributionen öffnet sich das Terminal durch die Tastenkombination [Strg] + [Alt] + [T].\n    *   Auf **MacOS** führt die Tastenkombination [cmd] + [Leertaste] zur Spotlight-Suche. Dort kann nach \"Terminal\" gesucht und dieser ausgeführt werden.\n\n*   Nun prüfen wir, ob auf unserem Betriebssystem _Node.js_ und _npm_ korrekt installiert wurden. Das geht mit den Terminal-Befehlen\n\n<pre class=\"code\">\nnode -v\nnpm -v</pre>\n\n*   Im besten Fall informiert dich dein Betriebssystem nun darüber, ob und in welcher Version _Node.js _und_ npm _installiert sind. Falls eine Fehlermeldung erscheint, solltest du den Installationsvorgang wiederholen.",
      "date": "2019-06-18",
      "title": "Einen Webserver einrichten (1): Node.js und npm installieren!\t",
      "slug": "node-js-und-npm-installieren",
      "createdAt": "2020-04-11T18:50:04.604Z",
      "updatedAt": "2020-04-11T20:45:45.333Z",
      "__v": 0,
      "id": "5e92115c3362d2001025ab20"
    },
    {
      "category": "tutorial",
      "_id": "5e9212153362d2001025ab21",
      "html": "<p class=\"intro\">Building a Twitter bot with Node.js is easy these days (if you have at least some web development & JavaScript knowledge). Get ready with me and set up your own one in just a few minutes.</p>\n\nAt first you will need to [register](https://twitter.com/signup) a (new) Twitter account specifiying the screen name, through which you'd like to tweet into the world. After that you are ready to apply for a developer's account and add a new Twitter developer's app [here](https://developer.twitter.com/en/apps). This is necessary for generating keys and tokens for accessing the official [Twitter API](https://developer.twitter.com/en/docs/basics/things-every-developer-should-know). Twitter asks for several information about what you want to do with your app. Writing down what the bot is all about went just fine for me. Finally it's time for coding. Make sure _node_ and _npm_ are installed on your computer with the following commands.\n\n<pre class=\"code\">\nnode -v\nnpm -v</pre>\n\nAfter that, we are ready to setup a working folder and init a npm project with:\n\n<pre class=\"code\">npm init</pre>\n\nThe only library that is mandatory for our project is the npm package _twitter-lite_, a tiny, full-featured, modern client / server library for the Twitter API, whose documentation you will find [here](https://github.com/draftbit/twitter-lite). It was built because existing ones [have not been recently maintained](https://github.com/desmondmorris/node-twitter), or depend on [outdated](https://github.com/ttezel/twit/issues/411) [libraries](https://github.com/ttezel/twit/issues/412). Within our working folder we create a Node.js script, which could be named \"bot.js\". \n\n<pre class=\"code\">\nconst Twitter = require(\"twitter-lite\");\nconst client = new Twitter({\n  consumer_key: 'xyz',\n  consumer_secret: 'xyz',\n  access_token_key: 'xyz',\n  access_token_secret: 'xyz'\n});</pre>\n\nThis creates a new authorized Twitter API client. All keys and secrets are available in your Twitter developer's account. \n\nWhat should the bot do exactly? Well, for example, we could filter all incoming new tweets around the world with the help of keywords or hashtags by opening up the Twitter Stream and providing some parameters, like so:\n\n<pre class=\"code\">\nconst parameters = {\n  language: \"en\",\n  track:\n    \"#girlswhocode,#girlsintech,#womenintech,#womenwhocode,#momsintech,#momswhocode\"\n};\n\nclient\n  .stream(\"statuses/filter\", parameters)\n  .on(\"start\", response => console.log(\"start\"))\n  .on(\"data\", async data => {\n    console.log(\"got data\", data.id_str);\n  })\n  .on(\"error\", error => console.log(\"error\", error))\n  .on(\"end\", response => console.log(\"end\")); </pre>\n\nInstead of just logging filtered tweets we could now automatically retweet those tweets by adding:\n\n<pre class=\"code\">\nconst url = \"statuses/retweet/${data.id_str}\";\nawait client.post(url);\n</pre>\n\nThat's it! Just start your script with\n\n<pre class=\"code\">node bot.js</pre>\n\nand your bot starts firing. There are many more possibilities on how the Twitter API can be used. You would like to deploy this app? Sure, you could [deploy on Heroku ](https://devcenter.heroku.com/articles/getting-started-with-nodejs)or use a hoster like [DigitalOcean](https://www.digitalocean.com/) that could run your app in the background with _pm2_. Beware: Your secrets and keys should be stored in environment variables! A great library to do so is [dot-env](https://www.npmjs.com/package/dotenv).\n\nHave fun!",
      "title": "How to: Build a Twitter bot with Node.js - fast!\t",
      "slug": "how-to-build-a-twitter-bot-with-node-js-fast",
      "date": "2019-06-26",
      "createdAt": "2020-04-11T18:53:09.628Z",
      "updatedAt": "2020-05-04T18:27:35.342Z",
      "__v": 0,
      "id": "5e9212153362d2001025ab21"
    },
    {
      "category": "misc",
      "_id": "5e9212aa3362d2001025ab22",
      "html": "<p class=\"intro\">Finally, I finished my #100DaysOfCode challenge I started on May 31st this year. The challenge is a great way to establish coding to become a daily habit, stop procrastinating and working on projects, that have been only ideas before. For me it also became a way to keep in practice, since I left my programmer's job for maternal leave. I wrote a short recap about what I did in 100 days time.</p>\n\n### What is the #100DaysOfCode challenge?\n\nThe challenge was established by [Alexander Kallaway](https://twitter.com/ka11away) and its website is available [here](https://www.100daysofcode.com/). There are just two rules: code every day and track your efforts on Twitter. I didn't stick to those rules 100%, but I am happy with the outcome nevertheless. You can follow my progress on this small [log book](https://github.com/gitfrosh/100-days-of-code/blob/master/r1-log.md.) I wrote during the time.\n\nFor many coding newbies, the #100DaysOfCode helps with first tutorials and bootcamps, but since this was not the case for me I collected some topics I wanted to learn about and projects I planned to build.\n\n### Which projects did I finish?\n\n##### [The Lord of the Rings API](https://the-one-api.herokuapp.com)\n\nThe \"API to rule them all\", the Lord of the Rings api, provides users with book, character, movie and quotes data. The api's documentation is available [here](https://the-one-api.herokuapp.com). This was my biggest project I finished during the challenge and it is also my favourite one. It's built with Hapi.js, server side rendering React.js and includes technologies like MongoDB and JSON Web Token authorization. In the future I would like to put this project on Open Source to make contributions possible. [Github repository](https://github.com/gitfrosh/lotr-api)\n\n##### [The friendly fem tech bot](https://twitter.com/femtech_)\n\nThe Node.js powered Twitter bot retweets female tech related tweets including #girlswhocode #womenintech #womenwhocode #womeninstem #femaletech #momswhocode and others. You can follow the [@femtech_](https://twitter.com/femtech_) bot on Twitter. \n\n##### [Blockchain simulator](https://gitfrosh.github.io/blockchain-simulator/)\n\nThis small app provides a basic blockchain simulation and is built in React.js. For this project I also [deployed](https://gitfrosh.github.io/blockchain-simulator/) an app to a static site hoster Github pages for the first time -  a straightforward experience. [Github repository](https://github.com/gitfrosh/blockchain-simulator)\n\n##### \"Track ur mood\" Electron.js app\n\nThis is an experimental small project that can track your daily moods. It is built to try out Electron.js app and runs on Next.js under the hood. Data is stored in a lowdb powered Node.js / Hapi.js backend. Plus, it is styled with a supercute Windows95 UI library. [Github repository](https://github.com/gitfrosh/track-ur-mood)\n\n##### [The false quotes generator](https://false-quotes-generator.herokuapp.com/)\n\nThe [false quotes generator](https://false-quotes-generator.herokuapp.com/) missmatches mostly Simpsons' quotes to famous people. For this project I tried out Svelte.js and Sapper, a new shiny Javascript framework with a Node.js / Polka backend. [Github repository](https://github.com/gitfrosh/false-code-generator)\n\n##### [Publish a npm package](https://www.npmjs.com/package/random-lotr-movie-quote)\n\nThis is my first move to publish a npm package and - hurray! - it returns a single Lord of the Rings movie quote. [Github repository](https://github.com/gitfrosh/random-lotr-movie-quote)\n\n##### [ueberdiespree.de](https://ueberdiespree.de)\n\nThis is my small portfolio website I revamped with the static site generator Gatsby.js and some responsiveness improvements. [Github repository](https://github.com/gitfrosh/ueberdiespree)\n\n### What else did I learn?\n\nWhenever I didn't feel like coding on a project I worked on [this Udemy course](https://www.udemy.com/the-complete-junior-to-senior-web-developer-roadmap/) by Andrei Neagoie which includes great material about advanced web development topics like performance enhancements, security, typescript, testing, CI/CD, server side rendering, and more. I also worked on advanced React.js topics like React hooks and React CSS styling. Furthermore a studied some DevOps related problems and created my first Docker container.\n\n### Should you do the #100DaysOfCode challenge too?\n\nTotally! The challenge can help to keep going: Learning to code, finishing projects, achieving your goals. A big plus is the huge community on Twitter. With like-minded people in your timeline staying away from procrastination is much more easier. [Start today!  ](https://www.100daysofcode.com/)",
      "slug": "100daysofcode-a-recap",
      "title": "#100DaysOfCode - a recap\t\t",
      "date": "2019-07-18",
      "createdAt": "2020-04-11T18:55:38.218Z",
      "updatedAt": "2020-04-11T18:55:38.218Z",
      "__v": 0,
      "id": "5e9212aa3362d2001025ab22"
    },
    {
      "id": "2f865b80-a9c4-11ea-bd77-996339d7f37e",
      "html": "asdsfsdf",
      "date": "2020-06-08",
      "slug": "asd",
      "category": "asd",
      "title": "ssasad",
      "createdAt": "2020-06-08T00:00:00.000Z",
      "updatedAt": "2020-06-08T00:00:00.000Z",
      "status": "published"
    }
  ]
}